* <2025-04-09 Wed> GE                                                :frågor:

1. Behöver det färdiga lexikonet verkligen passera genom transtool och
   därmmed vara beroende av de begränsningar som ordbasen där ger? Eller
   kan man kanske helt enkelt bara köra in det som finns i indata?
  Förmodligen inte ...

2. Vad händer om sv-material i indata inte (helt) överensstämmer med
   ordbasen? Finns ddet nåt sätt attt få med översättningarna ändå
   eller är sådant material bara att dumpa? Det kan gälla:
   - definition
   - sammansätttning
   - exempel
   - idiom
   - annat?
     
* <2025-04-17 Thu> GE
Lite kollar på täckningen för aktuell lexin sv-uppslag (unnder S) i
kelderashdaata:

#+begin_src bash
time grep '#01' s.txt | cut -f2- -d' ' | sed 's/\~//g' | raku api2.raku --status | grep '"Wordbase"' | sunis
#+end_src

: 1563       "Wordbase": "LSL4",
: 1439       "Wordbase": "LSL4"
: 
: real	2m12.952s
: user	0m57.943s
: sys 	0m4.713s

#+begin_src bash
time grep '#01' s.txt | cut -f2- -d' ' | sed 's/\~//g' | raku api2.raku --status > status_S.json
#+end_src

: real	2m16.439s
: user	0m58.635s
: sys 	0m4.699s

#+begin_src bash
grep '#01' s.txt | wc -l
#+end_src

:    3039

#+begin_src bash
grep '"Status"' status_S.json | sunis
#+end_src

: 1389       "Status": "found"
: 1369       "Status": "found",
:  147       "Status": "no unique matching",
:   52       "Status": "no unique matching"
:   37       "Status": "no matching"
:   31       "Status": "corrected",
:   14       "Status": "corrected"

<2025-04-26 Sat>
(Förhoppningsvis) samma körningssresultat med ny form för indata:

#+begin_src bash
   time cat ../kelderasch_filer/s.json | raku -MJSON::Fast -e '$*IN.slurp.&from-json.map: *.<#01>.subst("~", "|",:g).say' | raku api2.raku --status > status_swe-swe_S.json 
#+end_src

<2025-04-29 Tue>

Också för swe_fin (dvs. "Wordbase": "LSL3"):
#+begin_src bash
  time cat ../kelderasch_filer/s.json | raku -MJSON::Fast -e '$*IN.slurp.&from-json.map: *.<#01>.subst("~", "|",:g).say' | raku api2.raku --lang='swe>fin' --status > status_swe-fin_S.json 
#+end_src

Med statistik (för S):
#+begin_src bash
  cat  status_swe-fin_S.json | grep Status | raku -ne 'say .subst(/","\h*$/, "")' | sunis

  cat  status_swe-fin_S.json | grep ':' | raku -ne 'say .subst(/","\h*$/, "")' | sunis
#+end_src

: 2196       "Status": "found"
:  662       "Status": "corrected"
:  172       "Status": "no unique matching"
:    9       "Status": "no matching"

: 3030       "Wordbase": "LSL3"
: 2196       "Status": "found"
:  662       "Status": "corrected"
:  172       "Status": "no unique matching"
:    9       "Status": "no matching"

swe_swe (igen):
: 2994       "Wordbase": "LSL4"
: 2162       "Status": "found"
:  832       "Corrections": [
:  632       "Status": "corrected"
:  200       "Status": "no unique matching"
:   45       "Status": "no matching"

: 2162       "Status": "found"
:  632       "Status": "corrected"
:  200       "Status": "no unique matching"
:   45       "Status": "no matching"

* <2025-04-29 Tue>╭                                              :viggo_json:
Jag hade probllem med att få körning mot =LSL3= dvs. =swe_fin= att gå
igenom. Efter ganska mycket letande hittade jag det i brister i den
json som produceras av lexins (json)-API.

Enda fallet (under boksatven S) som ställer till problem är:
#+begin_src
"Value": "omv\u00e4nt snedstreck",
"Type": "subst.",
"VariantID": "12445",
[ ... ]
"Meaning": "tecknet \", 
#+end_src

där alltså sekvensen '\"' är ett specialtecken för inbäddade
dubbelfnuttar och vad saknas för att få giltig json är escapning av
'\': 
#+begin_src 
"Meaning": "tecknet \\", 
#+end_src

Jag har löst det temporärt genom att skriva om just den strängen till
den escapade motsvarigheten, men ska kontakta Viggo i ärendet,
fler kan ju få problem, exempelvis =lexin.se= som vad jag förstår
använder json-apiet ....

* COMMENT <2025-05-07 Wed>
Jag hittar allt fler fall där sökningar på det svenska uppslaget inte
ger det svar (beträffande ID och VariantID) som på nåt
tillfredställande sätt motsvarar informationen i
kelderashmaterialet. I vissa fall ID-värdena överenstämma men den
svenska diefinitionen eller nåt (svenskt) exempel skiljer sig åt. Även
då är det svårt att mappa samman dem ... Eller?

Jag borde sammanställa en liten hög med enxempel.

Jag kollade också lite på hur många oöversatta poster det finns i
materialet:

#+begin_src bash
cat ../kelderasch_filer/s.json | raku -MJSON::Fast -e 'for $*IN.slurp.&from-json { next if .<#31>; next if .<#02> ~~ /^"se "/; next if .<#54>; say .<#01> }' | wc -l
     156
#+end_src

#+begin_src bash
for f in  ../kelderasch_filer/*.json; do  cat $f | raku -MJSON::Fast -e 'for $*IN.slurp.&from-json { next if .<#31>; next if .<#02> ~~ /^"se "/; next if .<#54>; say .<#01> }'; done | wc -l
   2407
#+end_src

